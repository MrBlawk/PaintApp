<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector painting app</title>


    <link rel="stylesheet" href="styles.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <!-- Importing font awesome for easy access to vector icons for buttons -->
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
    <button type="button" class="collapsible">Menu</button>
    <div class="content">
        <div id="menubar">
            <div class="colorButtons">
                <h4>Colors</h4>
                <input type="color" value="#000000" id="pencilColorSelector" class="colorSelector">
            </div>

            <div class="colorButtons">
                <h4>Background color (refresh)</h4>
                <input type="color" value="#dee1d1" id="backgroundColorSelector" class="colorSelector">
            </div>

            <div class="pencilSize">
                <h4>Pencil size <span id="pencilSize">1</span></h4>
                <input type="range" id="pencilSizeSlider" min="1" max="20" value="1" step="1">
            </div>

            <div class="functions">
                <button id="eraserButton"><i class="fas fa-eraser"></i></button>
                <button id="undoButton"><i class="fas fa-rotate-left"></i></button>
                <button id="resetButton">reset</button>
            </div>



            <div class="functions">
                <h4>Import JSON and shapes</h4>
                <button id="importButton"><i class="fas fa-file-import"></i></button>
                <div class="dropdown">
                    <button class="btn border-dark btn-light dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="fa-solid fa-shapes"></i>
                    </button>
                    <ul class="dropdown-menu">
                      <ol id="shape-square"><i class="fa-solid fa-square"></i> Square</ol>
                      <ol id="shape-circle"><i class="fa-solid fa-circle"></i> Circle</ol>
                      <ol id="shape-triangle"><i class="fa-solid fa-play"></i> Triangle</ol>
                      <ol id="shape-heart"><i class="fa-solid fa-heart"></i> Heart</ol>
                    </ul>
                </div>
            </div>

            <div class="pencilSize">
                <h4>Rotation degrees: <span id="rotationAmountId">0</span></h4>
                <input type="range" id="rotationAmountSlider" min="0" max="360" value="0" step="1">
            </div>

            <div class="functions">
                <p>X-Axis offset</p>
                <input type="number" step="1" id="x-axis">
                <p>Y-Axis offset</p>
                <input type="number" step="1" id="y-axis">
            </div>

            <div class="colorButtons">
                <h4>Import Color</h4>
                <input type="color" value="#ff0000" id="importColorSelector" class="colorSelector">
            </div>

            <div class="importScale">
                <h4>Import size <span id="importSize">1</span></h4>
                <input type="range" id="importSizeSlider" min="0.1" max="4" value="1" step="0.1">
            </div>

            <div class="functions">
                <button id="downloadButton"><i class="fa-solid fa-download"></i></button>
            </div>


        </div>
    </div>
    


    <script>

        // Setting variables
        var mouseDown = false;
        var eraseEnabled = false;
        var canvas = document.createElement("canvas");
        var body = document.getElementsByTagName("body")[0];
        var sizeSlider = document.getElementById("pencilSize");
        var ctx = canvas.getContext('2d');
        
        var linesArray = [];
        currentSize = 5;
        lastSize = 5; 

        currentImportSize = 1;
        var importColor = "#ff0000";
        xAxisOffset = 0;
        yAxisOffset = 0; 
        var rotationAmount;

        var currentColor = "#000000";
        var lastColor;
        var currentBackground = "#dee1d1";

        //world coordinate variables
        var worldScale = 1;
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;

        const point = {
            x: centerX,
            y: centerY
        }

        //stroke ID
        let count = 0;


        //UI collapsing feature
        var coll = document.getElementsByClassName("collapsible");

        for (var i = 0; i < coll.length; i++) {
        coll[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var content = this.nextElementSibling;
            if (content.style.display === "block") {
            content.style.display = "none";
            } else {
            content.style.display = "block";
            }
        });
        }

        // Initialize drawing canvas
        createCanvas();

        // Button events //

        //Color picker
        document.getElementById("pencilColorSelector").addEventListener('change',
            function() {
                currentColor = this.value;
            }
        );

        //Background color picker
        document.getElementById("backgroundColorSelector").addEventListener('change',
            function() {
                currentBackground = this.value;
                createCanvas();
            }
        );

        //Pencil size
        document.getElementById("pencilSizeSlider").addEventListener('change',
            function(){
                currentSize = this.value;
                sizeSlider.innerHTML = currentSize;
            }
        );

        document.getElementById("rotationAmountSlider").addEventListener('change',
            function(){
                rotationAmount = this.value;
                rotationAmountId.innerHTML = this.value;   
                console.log(this.value)
            }
        )

        //x and y axis import offsets
        document.getElementById("x-axis").addEventListener('change',
            function(){
                xAxisOffset = this.value;
                console.log(this.value);
            }
        )

        document.getElementById("y-axis").addEventListener('change',
            function(){
                yAxisOffset = this.value;
                console.log(this.value);
            }
        )

        //import color selector
        document.getElementById("importColorSelector").addEventListener('change',
            function(){
                importColor = this.value;
            }
        )

        //import json scale slider
        document.getElementById("importSizeSlider").addEventListener('change', 
            function(){
                currentImportSize = this.value;
                importSize.innerHTML = currentImportSize;
            }
        )

        //download the canvas
        document.getElementById("downloadButton").addEventListener('click', function(){
            downloadCanvas(this, "canvas", "canvas.png");
        }, false);

        //Erase button 
        document.getElementById("eraserButton").addEventListener('click', erase);

        //reset canvas button
        document.getElementById("resetButton").addEventListener('click', createCanvas);

        document.getElementById("undoButton").addEventListener('click', undoLast);
        
        //importing button
        document.getElementById("importButton").addEventListener('click', importFile)

        //create shapes buttons
        //square
        document.getElementById("shape-square").addEventListener('click', 
            function(){
                let newShape = new Model("square");
                newShape.create();
        });
        //circle
        document.getElementById("shape-circle").addEventListener('click', 
            function(){
                let newShape = new Model("circle");
                newShape.create();
        });
        //triangle
        document.getElementById("shape-triangle").addEventListener('click', 
            function(){
                let newShape = new Model("triangle");
                newShape.create();
        });
        //heart
        document.getElementById("shape-heart").addEventListener('click', 
            function(){
                let newShape = new Model("heart");
                newShape.create();
        });

        //Mouse event handlers
        canvas.addEventListener('mousedown',
            function(){
                mousedown(canvas, event);
            }
        );

        canvas.addEventListener('mousemove',
            function(){
                mousemove(canvas, event);
            }
        );

        canvas.addEventListener('mouseup', mouseup);


        //Create canvas
        function createCanvas(){
            //reset the array
            linesArray = [];

            canvas.id = "canvas";
			canvas.width = parseInt(window.innerWidth * 0.9);
			canvas.height = parseInt(window.innerHeight * 0.9);

            canvas.style.border = "1px";
            canvas.style.zIndex = 8;
			canvas.style.position = "absolute";

            ctx.fillStyle = currentBackground;
            ctx.fillRect(0, 0, point.x * 2, point.y * 2);

            body.appendChild(canvas);

            //fix coordinates of canvas to world coordinates
            ctx.translate(centerX, centerY);
        }

        //Erase function, fills everything with current set background color
        function erase(btn){
            if(!eraseEnabled){
                eraseEnabled = true;
                lastSize = currentSize;
                lastColor = currentColor;
                currentSize = 50;
                currentColor = ctx.fillStyle;
                document.getElementById("eraserButton").style.backgroundColor = "#8f8f8f"
            }
            else{
                eraseEnabled = false;
                currentSize = lastSize;
                currentColor = lastColor;
                document.getElementById("eraserButton").style.backgroundColor = "#fff"
            }

        }

        //Get mouse position
        function getMousePos(canvas, evt){
            var rect = canvas.getBoundingClientRect();
            return{
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        //On mouse down start tracking line path
        function mousedown(canvas, evt){
			mouseDown = true;
			var currentPosition = convert(getMousePos(canvas, evt));
			ctx.moveTo(currentPosition.x, currentPosition.y)
			ctx.beginPath();
			ctx.lineWidth  = currentSize;
			ctx.lineCap = "round";
			ctx.strokeStyle = currentColor;
        };

        // On mouse move
		function mousemove(canvas, evt) {
            if(mouseDown){
            var currentPosition = convert(getMousePos(canvas, evt));
            ctx.lineTo(currentPosition.x, currentPosition.y)
            ctx.stroke();
            store(currentPosition.x, currentPosition.y, currentSize, currentColor, count);
            }
        }

        //example removing from array
        // var index = list.map(x => {
        // return x.Id;
        // }).indexOf(id);

        // list.splice(index, 1);
        // console.log(list);

        //work in progress
        function undoLast(){
            console.log(count);
            console.log(linesArray.length);
            linesArray = linesArray.filter((elem) => elem.n !== count);
            count--;
            console.log(linesArray.length);
            drawPaths();
            console.log(count);
        }

        //work in progress / drawing all stores lines from linesArray
        function drawPaths(){
        // delete everything
        createCanvas();
        // draw all the paths in the paths array
        // linesArray.forEach(line=>{
        //     ctx.beginPath(); 
        //     for(let i = 0; i < line.length; i++){
        //             ctx.lineTo(line[i].x,line[i].y); 
        //             ctx.strokeStyle = line[i].c;
        //             ctx.lineWidth = line[i].s;
        //             console.log(line[i].c)
        //         }
        //         ctx.stroke();
        //     })

        linesArray.forEach(function(){
            for(let i = 0; i < linesArray.length; i++){
                ctx.beginPath();
                ctx.lineTo(linesArray[i].x, linesArray[i].y);
                ctx.stroke();
            }})
        } 

        //Store data
        function store(x, y, s, c, n){
            var line = {
                "x": x,
                "y": y,
                "size": s,
                "color": c,
                "ID": n
            }
            linesArray.push(line);
        }

        //function to import shapes in json format, based on x and y coords
        async function importFile(){
            //fetch the test file
            const response = await fetch("test.json");
            const obj = await response.json();
            
            //save current state in order to restore after rotation is applied, helps to recover mouse to canvas coord tracking
            ctx.save();
            //rotation will be applied if slider is set to anything other than 0.
            ctx.rotate(rotationAmount * Math.PI / 180);
            ctx.beginPath();
            for(var i in obj){
                const coords = scale(obj[i]);
                ctx.lineTo(coords.x, coords.y);
                store(coords.x, coords.y, 1, importColor);
            }
            ctx.closePath();
            ctx.fillStyle = importColor;
            ctx.fill();
            ctx.fillStyle = currentBackground;
            ctx.restore();
        }

        //On mouse up
        function mouseup(){
            mouseDown = false;
            count++;
            store();
        }

        //converting window raster to world coordinates
        function convert(coords) {
            const x = (coords.x - centerX) / worldScale;
            const y = (coords.y - centerY) / worldScale;
            return { 
                x: x, 
                y: y
            };
        }

        //idea of a function to scale json coordinates according to screen size
        function scale(coords){
            let x = (coords.x * currentImportSize) + parseInt(xAxisOffset); //adjusted so 0,0 is center of screen.
            let y = (coords.y * currentImportSize) + parseInt(yAxisOffset * -1); //adjusted to flip y coords, offset makes sure 0,0 is center of screen
            return {
                x: x,
                y: y
            };
        }

        //inheritance concept
        class Shape {
            constructor(type){
                this.shapename = type;
            }
            present(){
                return "The shape is a " + this.shapename;
            }
        }

        class Model extends Shape {
            constructor(type, size, color){
                super(type);
                this.type = type;
                this.size = currentImportSize;
                this.color = importColor;
            }
            create(){
                //save current state in order to restore after rotation is applied, helps to recover mouse to canvas coord tracking
                ctx.save();
                //rotation will be applied if slider is set to anything other than 0.
                ctx.rotate(rotationAmount * Math.PI / 180);

                //begin drawing shape
                ctx.beginPath();
                ctx.lineWidth = this.size * 10;
                ctx.strokeStyle = this.color;
                console.log("Trying to create a " + this.type);
                switch (this.type) {
                    case "square":
                        ctx.rect(xAxisOffset, yAxisOffset, this.size * 100, this.size * 100);
                        break;
                    case "circle":
                        ctx.arc(xAxisOffset, yAxisOffset, this.size * 100, 0, 2* Math.PI);
                        break;
                    case "triangle":
                        ctx.moveTo(0, 0 );
                        ctx.lineTo((200 * this.size), (200 * this.size));
                        ctx.lineTo((-200 * this.size), (200 * this.size));
                        ctx.lineTo(0 , 0 );
                        break;
                    case "heart":

                        var width = 200 * this.size;
                        var height = 200 * this.size;
                        var x = 0, y = 0;
                        var topCurveHeight = height * 0.3;
                        ctx.moveTo(x, y + topCurveHeight);
                        // top left curve
                        ctx.bezierCurveTo(
                            x, y, 
                            x - width / 2, y, 
                            x - width / 2, y + topCurveHeight
                        );

                        // bottom left curve
                        ctx.bezierCurveTo(
                            x - width / 2, y + (height + topCurveHeight) / 2, 
                            x, y + (height + topCurveHeight) / 2, 
                            x, y + height
                        );

                        // bottom right curve
                        ctx.bezierCurveTo(
                            x, y + (height + topCurveHeight) / 2, 
                            x + width / 2, y + (height + topCurveHeight) / 2, 
                            x + width / 2, y + topCurveHeight
                        );

                        // top right curve
                        ctx.bezierCurveTo(
                            x + width / 2, y, 
                            x, y, 
                            x, y + topCurveHeight
                        );
                        break;
                    default:
                        break;
                }

                ctx.stroke();
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }
        }
		function downloadCanvas(link, canvas, filename) {
            console.log("trying to export")
			link.href = document.getElementById(canvas).toDataURL();
			link.download = filename;
            console.log(filename + " should have been downloaded.")
		}
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>