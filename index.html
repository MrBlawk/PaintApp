<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector painting app</title>


    <link rel="stylesheet" href="styles.css">
    <!-- Importing font awesome for easy access to vector icons for buttons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha512-xh6O/CkQoPOWDdYTDqeRdPCVd1SpvCA9XXcUnZS2FmJNp1coAFzvtCN9BmamE+4aHK8yyUHUSCcJHgXloTyT2A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
    <button type="button" class="collapsible">Menu</button>
    <div class="content">
        <div id="menubar">
            <div class="colorButtons">
                <h4>Colors</h4>
                <input type="color" value="#000000" id="pencilColorSelector" class="colorSelector">
            </div>

            <div class="colorButtons">
                <h4>Background color (refresh)</h4>
                <input type="color" value="#dee1d1" id="backgroundColorSelector" class="colorSelector">
            </div>

            <div class="pencilSize">
                <h4>Pencil size <span id="pencilSize">1</span></h4>
                <input type="range" id="pencilSizeSlider" min="1" max="20" value="1" step="1">
            </div>



            <div class="functions">
                <button id="eraserButton"><i class="fas fa-eraser"></i></button>
                <button id="undoButton"><i class="fas fa-rotate-left"></i></button>
                <button id="resetButton">reset</button>
            </div>

            <div class="functions">
                <h4>Import SVG</h4>
                <button id="importButton"><i class="fas fa-file-import"></i></button>
            </div>

            <div class="pencilSize">
                <h4>Rotation degrees: <span id="rotationAmountId">0</span></h4>
                <input type="range" id="rotationAmountSlider" min="0" max="360" value="0" step="1">
            </div>

            <div class="functions">
                <p>X-Axis offset</p>
                <input type="number" step="1" id="x-axis">
                <p>Y-Axis offset</p>
                <input type="number" step="1" id="y-axis">
            </div>

            <div class="colorButtons">
                <h4>Import Color</h4>
                <input type="color" value="#ff0000" id="importColorSelector" class="colorSelector">
            </div>

            <div class="importScale">
                <h4>Import size <span id="importSize">1</span></h4>
                <input type="range" id="importSizeSlider" min="0.1" max="4" value="1" step="0.1">
            </div>


        </div>
    </div>
    


    <script>
        //UI collapsing feature
        var coll = document.getElementsByClassName("collapsible");

        for (var i = 0; i < coll.length; i++) {
        coll[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var content = this.nextElementSibling;
            if (content.style.display === "block") {
            content.style.display = "none";
            } else {
            content.style.display = "block";
            }
        });
        }




        // Setting variables
        var mouseDown = false;
        var eraseEnabled = false;
        var canvas = document.createElement("canvas");
        var body = document.getElementsByTagName("body")[0];
        var sizeSlider = document.getElementById("pencilSize");
        var ctx = canvas.getContext('2d');
        
        var linesArray = [];
        currentSize = 5;
        lastSize = 5; 

        currentImportSize = 1;
        var importColor = "#ff0000";
        xAxisOffset = 0;
        yAxisOffset = 0; 
        var rotationAmount;

        var currentColor = "#000000";
        var lastColor;
        var currentBackground = "#dee1d1";

        //world coordinate variables
        var worldScale = 1;
        const centerX = window.innerWidth /2;
        const centerY = window.innerHeight / 2;

        //stroke ID
        let count = 0;

        const circle = {
            x: 350,
            y: -210,
            radius: 247
        }

        const point = {
            x: centerX,
            y: centerY
        }

        

        // Initialize drawing canvas
        createCanvas();

        // Button events

        //Color picker
        document.getElementById("pencilColorSelector").addEventListener('change',
            function() {
                currentColor = this.value;
            }
        );

        //Background color picker
        document.getElementById("backgroundColorSelector").addEventListener('change',
            function() {
                currentBackground = this.value;
                createCanvas();
            }
        );

        //Pencil size
        document.getElementById("pencilSizeSlider").addEventListener('change',
            function(){
                currentSize = this.value;
                sizeSlider.innerHTML = currentSize;
            }
        );

        document.getElementById("rotationAmountSlider").addEventListener('change',
            function(){
                rotationAmount = this.value;
                rotationAmountId.innerHTML = this.value;   
                console.log(this.value)
            }
        )

        //x and y axis import offsets
        document.getElementById("x-axis").addEventListener('change',
            function(){
                xAxisOffset = this.value;
                console.log(this.value);
            }
        )

        document.getElementById("y-axis").addEventListener('change',
            function(){
                yAxisOffset = this.value;
                console.log(this.value);
            }
        )

        //import color selector
        document.getElementById("importColorSelector").addEventListener('change',
            function(){
                importColor = this.value;
            }
        )

        //import json scale slider
        document.getElementById("importSizeSlider").addEventListener('change', 
            function(){
                currentImportSize = this.value;
                importSize.innerHTML = currentImportSize;
            }
        )

        //Erase button 
        document.getElementById("eraserButton").addEventListener('click', erase);

        //reset canvas button
        document.getElementById("resetButton").addEventListener('click', createCanvas);

        document.getElementById("undoButton").addEventListener('click', undoLast);
        
        //importing button
        document.getElementById("importButton").addEventListener('click', importFile)

        //Mouse event handlers
        canvas.addEventListener('mousedown',
            function(){
                mousedown(canvas, event);
            }
        );

        canvas.addEventListener('mousemove',
            function(){
                mousemove(canvas, event);
            }
        );

        canvas.addEventListener('mouseup', mouseup);


        //Create canvas
        function createCanvas(){
            canvas.id = "canvas";
			canvas.width = parseInt(window.innerWidth * 0.9);
			canvas.height = parseInt(window.innerHeight * 0.9);

            canvas.style.border = "1px";
            canvas.style.zIndex = 8;
			canvas.style.position = "absolute";

            ctx.fillStyle = currentBackground;
            ctx.fillRect(0, 0, point.x * 2, point.y * 2);

            body.appendChild(canvas);

            //fix coordinates of canvas to world coordinates
            ctx.translate(centerX, centerY);
        }

        //Erase function, fills everything with current set background color
        function erase(btn){
            if(!eraseEnabled){
                eraseEnabled = true;
                lastSize = currentSize;
                lastColor = currentColor;
                currentSize = 50;
                currentColor = ctx.fillStyle;
                document.getElementById("eraserButton").style.backgroundColor = "#8f8f8f"
            }
            else{
                eraseEnabled = false;
                currentSize = lastSize;
                currentColor = lastColor;
                document.getElementById("eraserButton").style.backgroundColor = "#fff"
            }

        }

        //Get mouse position
        function getMousePos(canvas, evt){
            var rect = canvas.getBoundingClientRect();
            return{
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        //On mouse down start tracking line path
        function mousedown(canvas, evt){
			mouseDown = true;
			var currentPosition = convert(getMousePos(canvas, evt));
			ctx.moveTo(currentPosition.x, currentPosition.y)
			ctx.beginPath();
			ctx.lineWidth  = currentSize;
			ctx.lineCap = "round";
			ctx.strokeStyle = currentColor;
        };

        // On mouse move
		function mousemove(canvas, evt) {
            if(mouseDown){
            var currentPosition = convert(getMousePos(canvas, evt));
            ctx.lineTo(currentPosition.x, currentPosition.y)
            ctx.stroke();
            store(currentPosition.x, currentPosition.y, currentSize, currentColor, count);
            }
        }

        //example removing from array
        // var index = list.map(x => {
        // return x.Id;
        // }).indexOf(id);

        // list.splice(index, 1);
        // console.log(list);

        //work in progress
        function undoLast(){
            console.log(count);
            console.log(linesArray.length);
            linesArray = linesArray.filter((elem) => elem.n !== count);
            count--;
            console.log(linesArray.length);
            drawPaths();
            console.log(count);
        }

        //work in progress / drawing all stores lines from linesArray
        function drawPaths(){
        // delete everything
        createCanvas();
        // draw all the paths in the paths array
        // linesArray.forEach(line=>{
        //     ctx.beginPath(); 
        //     for(let i = 0; i < line.length; i++){
        //             ctx.lineTo(line[i].x,line[i].y); 
        //             ctx.strokeStyle = line[i].c;
        //             ctx.lineWidth = line[i].s;
        //             console.log(line[i].c)
        //         }
        //         ctx.stroke();
        //     })

        linesArray.forEach(function(){
            for(let i = 0; i < linesArray.length; i++){
                ctx.beginPath();
                ctx.lineTo(linesArray[i].x, linesArray[i].y);
                ctx.stroke();
            }})
        } 

        //Store data
        function store(x, y, s, c, n){
            var line = {
                "x": x,
                "y": y,
                "size": s,
                "color": c,
                "ID": n
            }
            linesArray.push(line);
        }

        //function to import shapes in json format, based on x and y coords
        async function importFile(){
            //fetch the test file
            const response = await fetch("test.json");
            const obj = await response.json();
            
            //save current state in order to restore after rotation is applied, helps to recover mouse to canvas coord tracking
            ctx.save();
            //rotation will be applied if slider is set to anything other than 0.
            ctx.rotate(rotationAmount * Math.PI / 180);
            ctx.beginPath();
            for(var i in obj){
                const coords = scale(obj[i]);
                ctx.lineTo(coords.x, coords.y);
                store(coords.x, coords.y, 1, importColor);
                console.log(linesArray[linesArray.length-1])
            }
            ctx.closePath();
            ctx.fillStyle = importColor;
            ctx.fill();
            ctx.fillStyle = currentBackground;
            ctx.restore();
        }

        //On mouse up
        function mouseup(){
            mouseDown = false;
            count++;
            store();
        }

        //converting window raster to world coordinates
        function convert(coords) {
            const x = (coords.x - centerX) / worldScale;
            const y = (coords.y - centerY) / worldScale;
            return { 
                x: x, 
                y: y
            };
        }

        //idea of a function to scale json coordinates according to screen size
        function scale(coords){
            let x = (coords.x * currentImportSize) + parseInt(xAxisOffset); //adjusted so 0,0 is center of screen.
            let y = (coords.y * currentImportSize) + parseInt(yAxisOffset * -1); //adjusted to flip y coords, offset makes sure 0,0 is center of screen
            return {
                x: x,
                y: y
            };
        }

    </script>
</body>
</html>